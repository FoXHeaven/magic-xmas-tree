<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3Dé­”æ³•åœ£è¯æ ‘ - æœ€ç»ˆå¼ºåŠ›äº¤äº’ç‰ˆ</title>
    <style>
        /* 1. åŸºç¡€è®¾ç½®ï¼šç”»å¸ƒä½œä¸ºèƒŒæ™¯ */
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; width: 100%; height: 100%; position: fixed; }
        
        /* 2. 3D ç”»å¸ƒï¼šå½»åº•æ²‰åº•ï¼Œä¸æ¥æ”¶ä»»ä½•ç‚¹å‡» */
        canvas { 
            position: fixed; 
            top: 0; 
            left: 0; 
            z-index: -1; /* å…³é”®ï¼šè®¾ä¸ºè´Ÿæ•°ï¼Œæ°¸è¿œåœ¨æœ€åº•å±‚ */
            transform: scaleX(-1); /* é•œåƒ */
            pointer-events: none; 
        }

        /* 3. UI å®¹å™¨ï¼šä¿è¯å±‚çº§æœ€é«˜ */
        #ui-layer { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 9999; 
            width: 300px;
            pointer-events: none; /* å®¹å™¨æœ¬èº«ä¸æŒ¡é¼ æ ‡ */
        }

        /* 4. æŒ‰é’®ï¼šæ˜¾å¼å¼€å¯ç‚¹å‡»ï¼Œä¸”å¢åŠ ç‚¹å‡»åé¦ˆæ•ˆæœ */
        #upload-btn { 
            background: #e63946; 
            color: #fff; 
            border: 2px solid #fff; 
            padding: 12px 25px; 
            border-radius: 25px; 
            font-size: 15px;
            font-weight: bold; 
            cursor: pointer; 
            box-shadow: 0 4px 15px rgba(230,57,70,0.4); 
            pointer-events: auto; /* å…³é”®ï¼šå¼€å¯ç‚¹å‡» */
            user-select: none;
            transition: transform 0.1s;
            display: inline-block;
        }
        #upload-btn:active { transform: scale(0.9); background: #ff0000; } /* ç‚¹å‡»æ—¶çš„ç¼©æ”¾åé¦ˆ */

        #guide { 
            background: rgba(0,0,0,0.85); 
            padding: 15px; 
            border-radius: 12px; 
            border: 1px solid #ffd700; 
            margin-top: 15px; 
            backdrop-filter: blur(8px);
            pointer-events: none;
        }
        .gesture-item { margin-bottom: 8px; font-size: 13px; color: #eee; line-height: 1.4; }
        
        #input_video { display: none; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="upload-btn">ğŸ–¼ï¸ ä¸Šä¼ ç…§ç‰‡æŒ‚ä»¶</div>
        
        <div id="guide">
            <h3 style="margin:0 0 10px 0; color:#ffd700; font-size:16px;">ğŸ„ äº¤äº’æŒ‡å—</h3>
            <div class="gesture-item">1ï¸âƒ£ ğŸ‘Œ <b>æåˆ</b>ï¼šç²’å­èšé›†æˆæ ‘</div>
            <div class="gesture-item">2ï¸âƒ£ ğŸ–ï¸ <b>å¼ å¼€äº”æŒ‡</b>ï¼šæ•£å¼€é‡ç½®</div>
            <div class="gesture-item">3ï¸âƒ£ â˜ï¸ <b>é£ŸæŒ‡</b>ï¼šæŒ‡å‘é”å®šç…§ç‰‡</div>
            <div class="gesture-item">4ï¸âƒ£ âœŠ <b>æ¡æ‹³</b>ï¼šæ‹‰è¿‘ç…§ç‰‡æŸ¥çœ‹</div>
        </div>
    </div>

    <input type="file" id="real-file-input" accept="image/*" multiple style="display:none;">

    <video id="input_video" autoplay playsinline muted></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // --- æ ¸å¿ƒä¿®å¤ï¼šå¼ºåˆ¶ç‚¹å‡»ç»‘å®š ---
        const uiBtn = document.getElementById('upload-btn');
        const realInput = document.getElementById('real-file-input');

        // æ— è®ºæ˜¯åœ¨ç”µè„‘è¿˜æ˜¯ iPadï¼Œç‚¹å‡»çº¢è‰²æŒ‰é’®ï¼Œå¼ºåˆ¶è§¦å‘ Input çš„ç‚¹å‡»
        uiBtn.addEventListener('click', () => {
            realInput.click();
        });

        // --- Three.js åˆå§‹åŒ– ---
        const videoElement = document.getElementById('input_video');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ç¯å…‰ï¼šä¿®å¤é»‘è‰²äº”è§’æ˜Ÿ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffd700, 1.2);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        const treeGroup = new THREE.Group();
        treeGroup.scale.set(1.25, 1.25, 1.25); 
        scene.add(treeGroup);

        let hasUnlockedMagic = false;
        let isTreeFormed = false, isPointing = false, isFist = false;
        let rotationInertia = 0, lastHandX = 0.5;
        let lockedTarget = null; 
        const photos = [];
        const MAX_PHOTOS = 12;

        // --- ç²’å­ç³»ç»Ÿ ---
        const count = 25000;
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        const currentColors = new Float32Array(count * 3);
        const treeColors = new Float32Array(count * 3);
        const burstColor = new THREE.Color(0xffd700);
        const treePos = new Float32Array(count * 3);
        const burstPos = new Float32Array(count * 3);
        const driftSeed = new Float32Array(count);

        function updateBurstPositions() {
            const aspect = window.innerWidth / window.innerHeight;
            for(let i=0; i<count; i++){
                burstPos[i*3] = (Math.random() - 0.5) * 65 * aspect; 
                burstPos[i*3+1] = (Math.random() - 0.5) * 65;
                burstPos[i*3+2] = (Math.random() - 0.5) * 40;
                driftSeed[i] = Math.random() * Math.PI * 2;
            }
        }

        for(let i=0; i<count; i++){
            const h = Math.random() * 14; 
            const isTrunk = h < 2.2;
            let r, col;
            if(isTrunk) {
                r = 0.6 * Math.pow(Math.random(), 0.5);
                col = new THREE.Color(0x3d2b1f); 
            } else {
                r = (14 - h) * 0.38 * Math.pow(Math.random(), 0.7);
                if(Math.random() > 0.98) col = new THREE.Color().setHSL(Math.random(), 1.0, 0.6); 
                else {
                    col = new THREE.Color(0x0a3d0a).lerp(new THREE.Color(0x2e8b57), Math.random());
                    col.multiplyScalar(0.7 + (h/14)*0.5); 
                }
            }
            const a = Math.random() * Math.PI * 2;
            treePos[i*3] = Math.cos(a) * r; treePos[i*3+1] = h - 7; treePos[i*3+2] = Math.sin(a) * r;
            treeColors[i*3] = col.r; treeColors[i*3+1] = col.g; treeColors[i*3+2] = col.b;
            currentColors[i*3] = burstColor.r; currentColors[i*3+1] = burstColor.g; currentColors[i*3+2] = burstColor.b;
        }
        updateBurstPositions();
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(currentColors, 3));
        treeGroup.add(new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.02, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending })));

        // --- é›ªèŠ± ---
        const snowGeo = new THREE.BufferGeometry();
        const snowPosArr = new Float32Array(1200 * 3);
        for(let i=0; i<1200; i++) { snowPosArr[i*3]=(Math.random()-0.5)*50; snowPosArr[i*3+1]=Math.random()*40; snowPosArr[i*3+2]=(Math.random()-0.5)*40; }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPosArr, 3));
        const snowMat = new THREE.PointsMaterial({size: 0.05, color: 0xffffff, transparent: true, opacity: 0});
        scene.add(new THREE.Points(snowGeo, snowMat));

        // --- äº”è§’æ˜Ÿ (MeshPhongMaterial) ---
        function createGoldenStar() {
            const shape = new THREE.Shape();
            const outerRadius = 0.6; const innerRadius = 0.28;
            for (let i = 0; i < 10; i++) {
                const angle = (i * Math.PI) / 5 - Math.PI / 2;
                const r = i % 2 === 0 ? outerRadius : innerRadius;
                if (i === 0) shape.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                else shape.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
            }
            const starGeo = new THREE.ExtrudeGeometry(shape, { depth: 0.1, bevelEnabled: true, bevelThickness: 0.15, bevelSize: 0.05, bevelSegments: 1 });
            starGeo.center(); 
            const starMat = new THREE.MeshPhongMaterial({ color: 0xffd700, emissive: 0x332200, shininess: 80 });
            const group = new THREE.Group();
            group.add(new THREE.Mesh(starGeo, starMat));
            group.position.y = 7.4; group.visible = false;
            return group;
        }
        const starGroup = createGoldenStar();
        treeGroup.add(starGroup);

        // --- ç¥ç¦è¯­ ---
        function createGradientText(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1024; canvas.height = 256;
            ctx.translate(canvas.width, 0); ctx.scale(-1, 1);
            const grad = ctx.createLinearGradient(0, 0, canvas.width, 0);
            grad.addColorStop(0, '#ff0000'); grad.addColorStop(0.5, '#00ff00'); grad.addColorStop(1, '#00ffff');
            ctx.font = "bold 110px 'Georgia', serif"; ctx.fillStyle = grad; ctx.textAlign = "center";
            ctx.fillText(text, 512, 150);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
            sprite.scale.set(11, 2.75, 1);
            return sprite;
        }
        const christmasLabel = createGradientText("Merry Christmas");
        christmasLabel.position.set(0, 8.8, 0); christmasLabel.visible = false;
        treeGroup.add(christmasLabel);

        // --- å½©å¸¦ ---
        const ribbonMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0 });
        const ribbonPoints = [];
        for (let i = 0; i <= 100; i++) {
            const t = i / 100; const h = -4.5 + t * 11; const angle = t * Math.PI * 2 * 4.5; const r = (14 - (h+7)) * 0.42; 
            ribbonPoints.push(new THREE.Vector3(Math.cos(angle) * r, h, Math.sin(angle) * r));
        }
        const ribbonGroup = new THREE.Group();
        ribbonGroup.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(ribbonPoints), 100, 0.05, 8, false), ribbonMat));
        treeGroup.add(ribbonGroup);

        // --- æ‰‹åŠ¿å¼•æ“ ---
        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.75, minTrackingConfidence: 0.75 });
        
        hands.onResults((res) => {
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                const h = res.multiHandLandmarks[0];
                rotationInertia = (h[0].x - lastHandX) * 18; lastHandX = h[0].x;
                
                const dP = Math.hypot(h[4].x-h[8].x, h[4].y-h[8].y);
                const dS = Math.hypot(h[0].x-h[5].x, h[0].y-h[5].y);
                const tips = [8,12,16,20];
                
                // 1. æåˆ
                if (dP < dS * 0.4) { 
                    hasUnlockedMagic = true; 
                    isTreeFormed = true; 
                } 
                // 2. å¼ å¼€ (å¼ æ‰‹é‡ç½®åŠŸèƒ½å·²ç¡®è®¤æ‰¾å›)
                else if (tips.reduce((s,i)=> s + Math.hypot(h[i].x-h[0].x, h[i].y-h[0].y), 0) > dS * 5.5) { 
                    if(isTreeFormed) {
                         isTreeFormed = false; 
                         isFist = false; 
                         isPointing = false;
                    }
                }

                if (hasUnlockedMagic && isTreeFormed) {
                    const fistCheck = tips.every(i => Math.hypot(h[i].x-h[0].x, h[i].y-h[0].y) < dS * 1.2);
                    if (fistCheck) { 
                        isFist = true; isPointing = false; 
                    } else { 
                        isPointing = h[8].y < h[6].y && h[12].y > h[10].y; 
                        if (isPointing) isFist = false; else isFist = false;
                    }
                }
            }
        });

        new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480, facingMode: 'user'
        }).start();

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            const pArr = geo.attributes.position.array;
            const cArr = geo.attributes.color.array;

            for(let i=0; i<count; i++){
                const idx = i*3;
                let tx = isTreeFormed ? treePos[idx] : burstPos[idx];
                let ty = isTreeFormed ? treePos[idx+1] : burstPos[idx+1];
                let tz = isTreeFormed ? treePos[idx+2] : burstPos[idx+2];
                if(!isTreeFormed) { 
                    tx += Math.sin(time + driftSeed[i]) * 0.2; 
                    ty += Math.cos(time + driftSeed[i] * 1.1) * 0.2; 
                }
                pArr[idx]+=(tx-pArr[idx])*0.08; pArr[idx+1]+=(ty-pArr[idx+1])*0.08; pArr[idx+2]+=(tz-pArr[idx+2])*0.08;
                const tr = isTreeFormed ? treeColors[idx] : burstColor.r;
                const tg = isTreeFormed ? treeColors[idx+1] : burstColor.g;
                const tb = isTreeFormed ? treeColors[idx+2] : burstColor.b;
                cArr[idx]+=(tr-cArr[idx])*0.05; cArr[idx+1]+=(tg-cArr[idx+1])*0.05; cArr[idx+2]+=(tb-cArr[idx+2])*0.05;
            }
            geo.attributes.position.needsUpdate = true; geo.attributes.color.needsUpdate = true;
            
            treeGroup.rotation.y += rotationInertia * 0.08;
            starGroup.visible = christmasLabel.visible = isTreeFormed;
            
            if(isTreeFormed) {
                christmasLabel.position.y = 8.8 + Math.sin(time * 1.5) * 0.2;
                starGroup.rotation.y += 0.05;
                ribbonMat.opacity += (0.7 - ribbonMat.opacity) * 0.05;
                ribbonGroup.rotation.y += 0.015;
            } else { ribbonMat.opacity += (0 - ribbonMat.opacity) * 0.1; }

            snowMat.opacity += (isTreeFormed ? 0.8 : -snowMat.opacity) * 0.05;
            const sArr = snowGeo.attributes.position.array;
            for(let i=0; i<1200; i++){ sArr[i*3+1]-=0.05; if(sArr[i*3+1]<-20) sArr[i*3+1]=25; }
            snowGeo.attributes.position.needsUpdate = true;

            if (isTreeFormed && (isPointing || isFist)) {
                let minZ = Infinity; let bestTarget = null;
                photos.forEach(m => {
                    const worldPos = new THREE.Vector3(); m.getWorldPosition(worldPos);
                    const d = worldPos.distanceTo(camera.position);
                    if (d < minZ) { minZ = d; bestTarget = m; }
                });
                lockedTarget = bestTarget;
            } else { lockedTarget = null; }

            photos.forEach((m) => {
                m.material.opacity += (isTreeFormed ? 1 : -m.material.opacity) * 0.1;
                if (isTreeFormed && m === lockedTarget) {
                    if (isFist) {
                        const fPos = treeGroup.worldToLocal(new THREE.Vector3(0, 0, 11));
                        m.position.lerp(fPos, 0.15); m.scale.lerp(new THREE.Vector3(8.5, 8.5, 8.5), 0.15);
                        m.rotation.set(0, -treeGroup.rotation.y, 0);
                    } else { 
                        m.position.lerp(m.userData.relPos, 0.15); m.scale.lerp(new THREE.Vector3(2.2, 2.2, 2.2), 0.15); m.lookAt(camera.position); 
                    }
                } else {
                    m.position.lerp(m.userData.relPos, 0.1); m.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1); m.lookAt(camera.position); 
                }
            });

            renderer.render(scene, camera);
            camera.position.z = window.innerWidth > window.innerHeight ? 16 : 20;
        }
        animate();

        // ç»‘å®šä¸Šä¼ é€»è¾‘ (ç›‘å¬çœŸæ­£çš„ Input å˜åŒ–)
        realInput.addEventListener('change', (e) => {
            Array.from(e.target.files).slice(0, MAX_PHOTOS - photos.length).forEach((f) => {
                const url = URL.createObjectURL(f);
                new THREE.TextureLoader().load(url, (t) => {
                    const p = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.6), new THREE.MeshBasicMaterial({map:t, transparent:true, opacity:0, side:THREE.DoubleSide}));
                    const index = photos.length;
                    const h = (index / MAX_PHOTOS) * 8 - 2.5; 
                    const angle = index * (Math.PI * 2 / 4.8); 
                    const r = (14 - (h+7)) * 0.38 + 0.6;
                    p.userData.relPos = new THREE.Vector3(Math.cos(angle)*r, h, Math.sin(angle)*r);
                    p.position.copy(p.userData.relPos);
                    treeGroup.add(p); photos.push(p);
                });
            });
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); 
            updateBurstPositions();
        });
    </script>
</body>
</html>